{
  "hash": "3196ea3db8644f4b5c34ce1836d5330f",
  "result": {
    "markdown": "# Implementation of LGCP in INLA and INLABRU\n\n## INLA \n\nHaving completed air pollution modelling in `INLA` and `inlabru`, it is time to move on to the LGCP and the point process model. A couple of online resources about point process modelling in `INLA` include: <https://becarioprecario.bitbucket.io/spde-gitbook/ch-stapp.html#sec:burkitt> and <https://www.paulamoraga.com/book-spatial/point-process-modeling.html>. I'll again be relying on the Moraga book for template code.\n\nThe model fit here has intensity specified as \n$$\n\\lambda(s) = \\exp[\\beta_0 + f(s)].\n$$\nHere I only use an intercept and spatial field to model the intensity, so we won't have to worry about downloading any covariates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(INLA)\nlibrary(inlabru)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(rasterVis)\n```\n:::\n\nNow for the data. I'll use butterfly data from citizen science observations made in the Netherlands in 2023. The data is available in the GBIF repository <https://doi.org/10.15468/dl.p5cy6n>, which includes all butterfly observations uploaded to observation.org. So it's necessary to filter the dataset down to just the Netherlands. I also filter for the species *Lasiommata megera*. \n\nHere is a nice picture (Charles J. Sharp - Own work, from Sharp Photography, sharpphotography.co.uk, CC BY-SA 4.0, <https://commons.wikimedia.org/w/index.php?curid=81510351>):\n![Lasiommata megera](figures/Lasiommata_megera_male_Italy.jpg){width=\"50%\"}\n\nOnce the filtering is done, we are left with 2705 observations.\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- file.path(\"D:\", \"data\", \"gbif_observation_org_butterflies\", \"gbif_butterfly_observation-org\", \"gbif_subset_netherlands_lepidoptera.csv\")\nd <- read_delim(file_name, delim='\\t', col_types=cols(infraspecificEpithet=col_character()))\nd %>% filter(species==\"Lasiommata megera\") -> d\ndim(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2705   50\n```\n:::\n\n```{.r .cell-code}\nd <- st_as_sf(d, coords = c(\"decimalLongitude\", \"decimalLatitude\"))\nst_crs(d) <- \"EPSG:4326\"\n#projMercator <- \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0\n#+x_0=0 +y_0=0 +k=1 +units=km +nadgrids=@null +wktext +no_defs\"\nprojMercator <- st_crs(\"EPSG:3857\")$proj4string\n# Observed coordinates\nd <- st_transform(d, crs = projMercator)\n```\n:::\n\nBefore, I used the Netherlands map directly, but now there is some extra processing to do, due to little isolated boundaries within the main polygon of the Netherlands border.\n\n::: {.cell}\n\n```{.r .cell-code}\nlayers <- st_layers(file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"bestuurlijkegrenzen.gpkg\"))\n#print(str(layers))\nmap <- st_read(file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"bestuurlijkegrenzen.gpkg\"), layer = \"landsgrens\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `landsgrens' from data source \n  `D:\\data\\maps\\netherlands_bestuurlijkegrenzen_2021\\bestuurlijkegrenzen.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1 feature and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 10425.16 ymin: 306846.2 xmax: 278026.1 ymax: 621876.3\nProjected CRS: Amersfoort / RD New\n```\n:::\n\n```{.r .cell-code}\nmap <- st_union(map)\nmap <- st_as_sf(map)\n# there's a little isolated spec in the map!\nborder_polygon <- st_cast(map, \"POLYGON\")\nborder_polygon <- st_as_sfc(border_polygon)\ngeos <- lapply(border_polygon, function(x) x[1])\n#for (g in geos){\n#  plot(st_polygon(g))\n#}\n# Get the border polygon\nborder_final <- st_polygon(geos[[1]])\n# We still need sf object\nborder_final <- st_sfc(border_final, crs=st_crs(map))\nborder_final <- st_as_sf(border_final)\nplot(border_final)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmap <- border_final\nmap <- st_transform(map, crs = projMercator)\ncoo <- st_coordinates(d)\nggplot() + geom_sf(data = map) +\n  geom_sf(data = d) + coord_sf(datum = projMercator)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Save this for later\nst_write(map, file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"clean_nl_boundary.gpkg\"), append=F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDeleting layer `clean_nl_boundary' using driver `GPKG'\nWriting layer `clean_nl_boundary' to data source \n  `D:/data/maps/netherlands_bestuurlijkegrenzen_2021/clean_nl_boundary.gpkg' using driver `GPKG'\nWriting 1 features with 0 fields and geometry type Polygon.\n```\n:::\n:::\n\nSo that gives us a very clean map, with the location of Lasiommata megera observations.\n\nAs in the previous example for air pollution data, we again create prediction points across the spatial region. These will be the locations at which the intensity is predicted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# raster grid covering map\ngrid <- terra::rast(map, nrows = 50, ncols = 50)\n# coordinates of all cells\nxy <- terra::xyFromCell(grid, 1:ncell(grid))\n# transform points to a sf object\ndp <- st_as_sf(as.data.frame(xy), coords = c(\"x\", \"y\"),\n               crs = st_crs(map))\n\n# indices points within the map\nindicespointswithin <- which(st_intersects(dp, map,\n                                           sparse = FALSE))\n\n# points within the map\ndp <- st_filter(dp, map)\n\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp) + coord_sf(datum = projMercator)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/prediction-locations-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncoop <- st_coordinates(dp)\n```\n:::\n\nNext, build the mesh. I left the projection in meters here, so the max.edge has to reflect those units. I also found that the parameter estimates in this example were particularly sensitive to the resolution of the triangles in the mesh, so I chose a `max.edge`s that gave good estimates but also weren't too slow in the fitting process. The main takeaway here is that it is important to explore different meshes a bit and the effect of that on your model.\n\n::: {.cell}\n\n```{.r .cell-code}\nloc.d <- cbind(st_coordinates(map)[, 1], st_coordinates(map)[, 2])\nmesh <- inla.mesh.2d(loc.domain = loc.d, max.edge = c(30000, 50000), crs=crs(d))\nplot(mesh)\npoints(coo, col = \"red\")\naxis(1)\naxis(2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/mesh-1.png){width=672}\n:::\n\n```{.r .cell-code}\n(nv <- mesh$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 886\n```\n:::\n\n```{.r .cell-code}\n(n <- nrow(coo))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2705\n```\n:::\n:::\n\nUsing `spde <- inla.spde2.matern(mesh = mesh, alpha = 2, constr = TRUE)` led to some differences in the `inla` and `INLABRU` models, mainly in that the intercept was quite different between the two. So I started to use the Penalized Complexity priors on the matern function instead. The PC priors can be read about in @simpson2017. ```prior.range```$=(\\rho$,$p_{\\rho})$ specifies $P(\\rho < \\rho_0)=p_ρ$, the probability that the range is less than a certain amount $\\rho_0$. This indicates how likely it is that the spatial range of the field degrades quickly. The same can be said for ```prior.sigma```, only for the marginal standard deviation of the field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspde <- inla.spde2.pcmatern(mesh = mesh, alpha = 2, constr = TRUE, prior.range = c(10, 0.1), prior.sigma = c(1, 0.01))\n```\n:::\n\nIn the point process setting, it is necessary to use the method of @simpson2016. This uses a dual mesh to approximate the point process likelihood. It is called a dual mesh because a mesh of polygons is generated, each centered around the vertices of the triangles in the first mesh. The code to create the dual mesh is available in both the SPDE book and Moraga book.\n\n::: {.cell}\n\n```{.r .cell-code}\nbook.mesh.dual <- function(mesh) {\n    if (mesh$manifold=='R2') {\n        ce <- t(sapply(1:nrow(mesh$graph$tv), function(i)\n            colMeans(mesh$loc[mesh$graph$tv[i, ], 1:2])))\n        library(parallel)\n        pls <- mclapply(1:mesh$n, function(i) {\n            p <- unique(Reduce('rbind', lapply(1:3, function(k) {\n            j <- which(mesh$graph$tv[,k]==i)\n            if (length(j)>0) \n            return(rbind(ce[j, , drop=FALSE],\n            cbind(mesh$loc[mesh$graph$tv[j, k], 1] +\n            mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 1], \n            mesh$loc[mesh$graph$tv[j, k], 2] +\n            mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 2])/2))\n            else return(ce[j, , drop=FALSE])\n            })))\n            j1 <- which(mesh$segm$bnd$idx[,1]==i)\n            j2 <- which(mesh$segm$bnd$idx[,2]==i)\n            if ((length(j1)>0) | (length(j2)>0)) {\n            p <- unique(rbind(mesh$loc[i, 1:2], p,\n            mesh$loc[mesh$segm$bnd$idx[j1, 1], 1:2]/2 +\n            mesh$loc[mesh$segm$bnd$idx[j1, 2], 1:2]/2, \n            mesh$loc[mesh$segm$bnd$idx[j2, 1], 1:2]/2 +\n            mesh$loc[mesh$segm$bnd$idx[j2, 2], 1:2]/2))\n            yy <- p[,2]-mean(p[,2])/2-mesh$loc[i, 2]/2\n            xx <- p[,1]-mean(p[,1])/2-mesh$loc[i, 1]/2\n            }\n            else {\n            yy <- p[,2]-mesh$loc[i, 2]\n            xx <- p[,1]-mesh$loc[i, 1]\n            }\n            Polygon(p[order(atan2(yy,xx)), ])\n        })\n        return(SpatialPolygons(lapply(1:mesh$n, function(i)\n            Polygons(list(pls[[i]]), i))))\n    }\n    else stop(\"It only works for R2!\")\n}\ndmesh <- book.mesh.dual(mesh)\nplot(dmesh)\naxis(1)\naxis(2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/dual-mesh-1.png){width=672}\n:::\n:::\n\nWe then do something a little tricky. The mesh is larger than the domain that the points were observed in or the study region. So the intersections between the polygons in the mesh and the locations in $D$ are computed and the integration weights are returned based on the overlap. \n\n::: {.cell}\n\n```{.r .cell-code}\ndomain.polys <- Polygons(list(Polygon(loc.d)), '0')\ndomainSP <- SpatialPolygons(list(domain.polys))\ndomain_sf <- st_as_sf(domainSP)\ndomain_sf <- st_set_crs(domain_sf, projMercator)\nmesh_sf <- st_as_sf(dmesh)\nmesh_sf <- st_set_crs(mesh_sf, projMercator)\n# Check if the mesh polygons overlap with any of the locations \nw <- sapply(1:length(dmesh), function(i) {\n  if(length(st_intersects(mesh_sf[i,], domain_sf)[[1]])>0){\n    return(sf::st_area(sf::st_intersection(mesh_sf[i, ], domain_sf)))\n  }\n  else return(0)\n})\n\n# Fun little exercise as an alternative way to calculate the weights.\n# dp <- fm_pixels(mesh, dims = c(50, 50), mask = domain_sf)\n# # Project mesh basis functions to pixel locations and multiply by pixel weights \n# # Sum these contributions for each basis function \n# A_pixels <- fm_basis(mesh, loc = dp)\n# pixel_weights <- st_area(dp)\n# pixel_weights <- as.numeric(pixel_weights)\n# A_weighted <- Diagonal(length(pixel_weights), pixel_weights) %*% A_pixels\n# w <- Matrix::colSums(A_weighted)\n# w <- as.vector(w)\n# sum(w)\n\nsum(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 111060620373\n```\n:::\n\n```{.r .cell-code}\nst_area(map)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n111060620373 [m^2]\n```\n:::\n:::\n\nNotice that the weights and and the area of the domain are the same. \n\nWe can see in the plot below that we are left with a very nice looking mesh, where the black integration points fall within the Netherlands domain and red fall outside of it.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mesh)\nplot(domain_sf, add=T)\npoints(mesh$loc[which(w > 0), 1:2], col = \"black\", pch = 20)\npoints(mesh$loc[which(w == 0), 1:2], col = \"red\", pch = 20)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/plot-mesh-1.png){width=672}\n:::\n:::\n\nNext, create the `INLA` stack, for both observations and for prediction points. In the first section I didn't provide that much detail about the stack, so I'll explain it in more detail here. \n\nFirst we create vectors for the observed response and for estimation. For `y.pp`, `nv` is the number of mesh nodes and `n` is the number of observations, where there will be a 0 for each element of length `nv` and a 1 for each of length `n`. `e.pp` will consist of the integration weights `w` of length `nv` and a set of 0s of length `n`. This is for the numerical integration in the LGCP likelihood. Just as in the point process likelihood, we have two components: An intractable integral to be approximated, and a product of point locations: \n$$\nL(\\lambda)\\propto\\prod_iλ(s_i​)\\exp\\left(−\\int_D\\lambda(s)ds\\right).\n$$\n\n::: {.cell}\n\n```{.r .cell-code}\ny.pp <- rep(0:1, c(nv, n))\nlength(y.pp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3591\n```\n:::\n\n```{.r .cell-code}\ne.pp <- c(w, rep(0, n))\nlength(e.pp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3591\n```\n:::\n:::\n\nNext set up the projection matrix. This will be used to compute the linear predictor, generally written\n$$\n\\boldsymbol{\\eta} = \\boldsymbol{1}\\beta_0 + \\boldsymbol{Az}.\n$$\nwhere $\\boldsymbol{z}=\\{z_1,z_2,,,z_{n_v}\\}$ will be the values of the spatial field at the nodes.\n\nIn the model here, we have both nodes and observed locations, $\\boldsymbol{z}=\\{z_1,z_2,,,z_{n_v}, z_{{n_v+1}}, ...,z_{n_v+n}\\}$, and the points for prediction, $\\boldsymbol{z}_{pred}=\\{z_1,z_2,,,z_{n_{pred}}\\}$. So we can write that all out as\n$$\n\\begin{aligned}\n\\begin{pmatrix}\n\\boldsymbol{\\eta}_{node} \\\\\n\\boldsymbol{\\eta}_{obs}\n\\end{pmatrix} &= \n\\begin{pmatrix}\n\\boldsymbol{1}_{n_v}\\\\\n\\boldsymbol{1}_n\n\\end{pmatrix}\\beta_0 +\n\\begin{pmatrix}\n\\boldsymbol{A}_{n_v}\\\\\n\\boldsymbol{A}_n\n\\end{pmatrix}\\boldsymbol{z}\\\\\n\\boldsymbol{\\eta}_{npred} &= \n\\boldsymbol{1}_{npred}\n\\beta_0 +\n\\boldsymbol{A}_{npred}\n\\boldsymbol{z}_{pred}\n\\end{aligned},\n$$\nso that there is a response for each component, an intercept for each, and a projection matrix for each. The below code reflects this. Notice that for `A.y` and `A.pp`, we use the function `inla.spde.make.A()`. This function interpolates the values of the spatial field at the observed location using the triangles in the mesh that each location falls within.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Projection matrix for the integration points \n# It is diagonal here because the values of the mesh vertices are the integration points themselves.\nA.int <- Diagonal(nv, rep(1, nv))\n# matrix for observed points \nA.y <- inla.spde.make.A(mesh = mesh, loc = coo)\n# matrix for mesh vertices and locations\nA.pp <- rbind(A.int, A.y)\n\n# We also create the projection matrix Ap.pp for the prediction locations.\nAp.pp <- inla.spde.make.A(mesh = mesh, loc = coop)\n```\n:::\n\nThen create the stacks themselves. We provide the response and estimation vectors to the `data` argument and the A projection matrices to the `A` argument. The `effect` argument takes the intercept and the index of spatial effects. If we had covariates, this is where we would provide them, also in a list.\n\n::: {.cell}\n\n```{.r .cell-code}\n# stack for estimation\nstk.e.pp <- inla.stack(tag = \"est.pp\",\ndata = list(y = y.pp, e = e.pp), \nA = list(1, A.pp),\neffects = list(list(b0 = rep(1, nv + n)), list(s = 1:nv)))\n\n# stack for prediction stk.p\nstk.p.pp <- inla.stack(tag = \"pred.pp\",\ndata = list(y = rep(NA, nrow(coop)), e = rep(0, nrow(coop))),\nA = list(1, Ap.pp),\neffects = list(data.frame(b0 = rep(1, nrow(coop))),\n               list(s = 1:nv)))\n\n# stk.full has stk.e and stk.p\nstk.full.pp <- inla.stack(stk.e.pp, stk.p.pp)\n```\n:::\n\nFinally, we can fit the model. This looks about the same as in the continuous setting. Notice the different strategy options for both the integration strategy and for the posterior approximation itself. `control.predictor` returns the posterior marginals for the observed and node locations, with `link=1` using the same link function as given in `family = 'poisson'` earlier. \n\n::: {.cell}\n\n```{.r .cell-code}\nformula <- y ~ -1 + b0 + f(s, model = spde)\nres <- inla(formula,  family = 'poisson',\n  data = inla.stack.data(stk.full.pp),\n  control.inla=list(int.strategy = 'grid', strategy=\"adaptive\"),\n  control.predictor = list(compute = TRUE, link = 1,\n    A = inla.stack.A(stk.full.pp)),\n    E = inla.stack.data(stk.full.pp)$e,\n  control.fixed=list(prec = 0.001))\n```\n:::\n\n`prec = 0.001` sets a vague Gaussian prior, $N(0, \\sigma^2=1/\\text{prec})$.\n\nWe can check the estimate for the intercept, as well as the parameters for the spatial field.\n\n::: {.cell}\n\n```{.r .cell-code}\nres$summary.fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        mean         sd 0.025quant  0.5quant 0.975quant      mode kld\nb0 -17.53066 0.01922714  -17.56835 -17.53066  -17.49298 -17.53066   0\n```\n:::\n\n```{.r .cell-code}\nres$summary.hyperpar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mean          sd 0.025quant   0.5quant 0.975quant       mode\nRange for s 106.7471710 263.8429977 7.25852152 42.6774769 619.967476 14.9620415\nStdev for s   0.3656843   0.4412572 0.03915794  0.2339294   1.508595  0.1009712\n```\n:::\n:::\n\nThen extract the predictions.\n\n::: {.cell}\n\n```{.r .cell-code}\nindex <- inla.stack.index(stk.full.pp, tag = \"pred.pp\")$data\npred_mean <- res$summary.fitted.values[index, \"mean\"]\npred_ll <- res$summary.fitted.values[index, \"0.025quant\"]\npred_ul <- res$summary.fitted.values[index, \"0.975quant\"]\ngrid$mean <- NA\ngrid$ll <- NA\ngrid$ul <- NA\n\ngrid$mean[indicespointswithin] <- pred_mean\ngrid$ll[indicespointswithin] <- pred_ll\ngrid$ul[indicespointswithin] <- pred_ul\n```\n:::\n\nAnd plot the predicted intensity\n\n::: {.cell}\n\n```{.r .cell-code}\n#levelplot(raster::brick(grid), layout = c(3, 1),\n#names.attr = c(\"Mean\", \"2.5 percentile\", \"97.5 percentile\"))\n# Ah that looks good! There is some numerical problem, or my predictions are on the wrong scale.\nmin_val <- global(log(grid$mean), \"min\", na.rm = TRUE)[[1]]\nmax_val <- global(log(grid$mean), \"max\", na.rm = TRUE)[[1]]\nggplot() +\n  geom_spatraster(data = log(grid$mean)) +\n  labs(title = \"Predicted intensity on log linear scale\",\n       fill = \"Intensity\") +\n  scale_fill_viridis_c(limits=c(min_val, max_val), breaks = seq(min_val, max_val, length.out = 10)) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/plot-preds-inla-1.png){width=672}\n:::\n:::\n\nWe can see in the legend that the intensity changes must be very small, because even on the log scale the legend values do not change. This is discussed more in the next section.\n\n## Inlabru\n\nNext: Inlabru. Firstly, we have to make sure to get the domain for the sampler correct. The INLA code does it above, but inlabru by default does not. More about that here <https://inlabru-org.github.io/inlabru/articles/2d_lgcp_plotsampling.html>\nand actually the exact problem here: <https://groups.google.com/g/r-inla-discussion-group/c/0bBC9bVV-L4> even though the problem was with preferential sampling. We had already done this in the code above to get the domain correct for INLA. Even with including ```sampler=domain_sf``` here, the estimates are not exactly the same as INLA, but closer than it was before.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nips <- fm_int(\n  domain = list(geometry = mesh),\n  samplers = domain_sf\n)\n\nggplot() +\n  geom_fm(data = mesh) +\n  gg(ips, aes(size = weight)) +\n  scale_size_area(max_size = 1)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/inlabru-domain-1.png){width=672}\n:::\n:::\n\n\nThen fit the ```inlabru``` model and check the summary output:\n\n::: {.cell}\n\n```{.r .cell-code}\nformula_inlabru <- geometry ~ -1 + b0(1) + f(geometry, model = spde)\nfit1 <- lgcp(formula_inlabru, data=d, samplers=domain_sf, domain = list(geometry = mesh), \n             options = list(control.inla=list(int.strategy = 'grid', strategy=\"laplace\"),\n                            control.fixed=list(prec = 0.001)))\nsummary(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.12.0\nINLA version: 24.05.01-1\nComponents:\nb0: main = linear(1), group = exchangeable(1L), replicate = iid(1L), NULL\nf: main = spde(geometry), group = exchangeable(1L), replicate = iid(1L), NULL\nLikelihoods:\n  Family: 'cp'\n    Tag: ''\n    Data class: 'sf', 'data.frame'\n    Response class: 'numeric'\n    Predictor: geometry ~ .\n    Used components: effects[b0, f], latent[]\nTime used:\n    Pre = 1.62, Running = 4.48, Post = 0.783, Total = 6.88 \nFixed effects:\n      mean    sd 0.025quant 0.5quant 0.975quant    mode kld\nb0 -17.531 0.019    -17.569  -17.531    -17.493 -17.531   0\n\nRandom effects:\n  Name\t  Model\n    f SPDE2 model\n\nModel hyperparameters:\n                mean       sd 0.025quant 0.5quant 0.975quant    mode\nRange for f 13174.36 32471.08     897.63  5279.36   76437.17 1852.30\nStdev for f    15.57    18.79       1.66     9.96      64.25    4.29\n\nDeviance Information Criterion (DIC) ...............: -134227.70\nDeviance Information Criterion (DIC, saturated) ....: NA\nEffective number of parameters .....................: -135917.29\n\nWatanabe-Akaike information criterion (WAIC) ...: 10595.91\nEffective number of parameters .................: 3619.61\n\nMarginal log-Likelihood:  -68811.10 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\n$\\beta_0$ is -17, which is quite low because the average baseline intensity $n_{obs}/|D|$ is expected to be very small. This is because there are not that many observations (2705) over the whole of the Netherlands, especially not per/meter.\n\nWe can again make predictions across the domain, exponentiating the linear predictor, using the generated prediction points.  \n\n::: {.cell}\n\n```{.r .cell-code}\npredictions1 <- predict(fit1, newdata=dp, formula = ~ exp(b0 + f))\npredictions2 <- predict(fit1, newdata=dp, formula = ~ exp(f))\nggplot() +\ngeom_sf(data=predictions1, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/preds-intensity-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Check the contribution of just the spatial field\nggplot() +\ngeom_sf(data=predictions2, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/preds-intensity-2.png){width=672}\n:::\n:::\n\nThe spatial field looks reasonable. The estimated values of the intensity are so small because we are working on the scale of meters and there are not that many observations, so per meter we do not expect the intensity to be very strong, i.e., it is not very likely for a point observation to occur within any square meter. We can get better resolution and a smoother field if the number of prediction points is higher. I observed that the PC prior for the range of the matern covariance structure $\\rho$ has quite an effect, especially since there are no covariates here. That's another thing to look out for in your own applications. \n\nThat concludes my demonstrations using the `INLA` and `inlabru` software. This may hopefully serve as a useful reference for someone, that someone being at least myself. As can be seen, the INLA modelling approach is quite flexible and can be used to construct all sorts of models. Constructing the model isn't the easiest thing in the world though, and understanding each element can take a while. But the advantage is that once you are comfortable with it, there is a lot that can be done all under the same INLA umbrella. `inlabru` is a lot easier to use than `INLA` but it makes some assumptions under the hood that may be advantageous from a statistical perspective (more efficient, robust), but wave away some of the important complexity and the connection of the software to the method of INLA itself. In the end, this blog post was more about INLA than it was about LGCPs, but one begets the other and so it was the natural order of things.\n\n",
    "supporting": [
      "inla_inlabru_lgcp_tutorial_netherlands_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}