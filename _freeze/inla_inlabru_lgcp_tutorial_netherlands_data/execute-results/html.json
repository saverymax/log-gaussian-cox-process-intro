{
  "hash": "eb964aa05cc82b4f13276566f064c88f",
  "result": {
    "markdown": "\n# Implementation of LGCP in INLA and INLABRU\n\nHaving completed an examination of Air Pollutoin modelling in INLA and INLABRU, it is time to move on to modelling the point process\n\nUsing data from GBIF.org (10 January 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.p5cy6n\n\n## LGCP in INLA introduction\n\nFollowing https://www.paulamoraga.com/book-spatial/point-process-modeling.html for the INLA intro.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(INLA)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sp\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is INLA_24.05.01-1 built 2024-05-01 18:49:50 UTC.\n - See www.r-inla.org/contact-us for how to get help.\n - List available models/likelihoods/etc with inla.list.models()\n - Use inla.doc(<NAME>) to access documentation\n```\n:::\n\n```{.r .cell-code}\nlibrary(inlabru)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: fmesher\n```\n:::\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.11.2, GDAL 3.8.2, PROJ 9.3.1; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(viridis)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: viridisLite\n```\n:::\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nterra 1.7.78\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:terra':\n\n    intersect, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(readr)\n```\n:::\n\n\nTODO: Fix issue reading data. StillIMage is doing something\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- file.path(\"D:\", \"data\", \"gbif_observation_org_butterflies\", \"gbif_butterfly_observation-org\", \"gbif_subset_netherlands_lepidoptera.csv\")\nd <- read_delim(file_name, delim='\\t', col_types=cols(infraspecificEpithet=col_character()))\nd %>% filter(species==\"Lasiommata megera\") -> d\ndim(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2705   50\n```\n:::\n\n```{.r .cell-code}\nsum(is.na(d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45001\n```\n:::\n\n```{.r .cell-code}\nd <- st_as_sf(d, coords = c(\"decimalLongitude\", \"decimalLatitude\"))\nst_crs(d) <- \"EPSG:4326\"\nst_crs(\"EPSG:3857\")$proj4string\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"\n```\n:::\n\n```{.r .cell-code}\nprojMercator <- st_crs(\"EPSG:3857\")$proj4string\nprojMercator\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"\n```\n:::\n\n```{.r .cell-code}\n# Observed coordinates\nd <- st_transform(d, crs = projMercator)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 2705 features and 48 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 411882.1 ymin: 6577190 xmax: 740274.6 ymax: 7066673\nProjected CRS: WGS 84 / Pseudo-Mercator\n# A tibble: 2,705 × 49\n       gbifID datasetKey    occurrenceID kingdom phylum class order family genus\n *      <dbl> <chr>         <chr>        <chr>   <chr>  <chr> <chr> <chr>  <chr>\n 1 4160322107 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 2 4409008265 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 3 4462065068 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 4 4160750394 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 5 4159129901 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 6 4410120094 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 7 4410216900 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 8 4409871777 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n 9 4409311703 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n10 4158114004 8a863029-f43… https://obs… Animal… Arthr… Inse… Lepi… Nymph… Para…\n# ℹ 2,695 more rows\n# ℹ 40 more variables: species <chr>, infraspecificEpithet <chr>,\n#   taxonRank <chr>, scientificName <chr>, verbatimScientificName <chr>,\n#   verbatimScientificNameAuthorship <lgl>, countryCode <chr>, locality <chr>,\n#   stateProvince <chr>, occurrenceStatus <chr>, individualCount <dbl>,\n#   publishingOrgKey <chr>, coordinateUncertaintyInMeters <dbl>,\n#   coordinatePrecision <lgl>, elevation <lgl>, elevationAccuracy <lgl>, …\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n?st_layers\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nstarting httpd help server ... done\n```\n:::\n\n```{.r .cell-code}\nlayers <- st_layers(file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"bestuurlijkegrenzen.gpkg\"))\n#print(str(layers))\nmap <- st_read(file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"bestuurlijkegrenzen.gpkg\"), layer = \"landsgrens\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `landsgrens' from data source \n  `D:\\data\\maps\\netherlands_bestuurlijkegrenzen_2021\\bestuurlijkegrenzen.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1 feature and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 10425.16 ymin: 306846.2 xmax: 278026.1 ymax: 621876.3\nProjected CRS: Amersfoort / RD New\n```\n:::\n\n```{.r .cell-code}\nmap <- st_union(map)\nmap <- st_as_sf(map)\nplot(map)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Damn it, there's a little isolated spec in the map!\nborder_polygon <- st_cast(map, \"POLYGON\")\nborder_polygon <- st_as_sfc(border_polygon)\ngeos <- lapply(border_polygon, function(x) x[1])\nfor (g in geos){\n  plot(st_polygon(g))\n}\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-9.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-10.png){width=672}\n:::\n\n```{.r .cell-code}\n# Get the border polygon\nborder_final <- st_polygon(geos[[1]])\n# We still need sf object\nborder_final <- st_sfc(border_final, crs=st_crs(map))\nborder_final <- st_as_sf(border_final)\nplot(border_final)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-11.png){width=672}\n:::\n\n```{.r .cell-code}\nmap <- border_final\nmap <- st_transform(map, crs = projMercator)\ncoo <- st_coordinates(d)\nggplot() + geom_sf(data = map) +\n  geom_sf(data = d) + coord_sf(datum = projMercator)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/map-12.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# raster grid covering map\ngrid <- terra::rast(map, nrows = 50, ncols = 50)\n# coordinates of all cells\nxy <- terra::xyFromCell(grid, 1:ncell(grid))\n# transform points to a sf object\ndp <- st_as_sf(as.data.frame(xy), coords = c(\"x\", \"y\"),\n               crs = st_crs(map))\n\n# indices points within the map\nindicespointswithin <- which(st_intersects(dp, map,\n                                           sparse = FALSE))\n\n# points within the map\ndp <- st_filter(dp, map)\n\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp) + coord_sf(datum = projMercator)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/prediction-locations-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncoop <- st_coordinates(dp)\n```\n:::\n\n\nHmm, why do I need such a large unit? Something with mercator? Oh, am I in meters?\n\n::: {.cell}\n\n```{.r .cell-code}\nmap\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 0 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 368237.9 ymin: 6577255 xmax: 804561.4 ymax: 7090341\nProjected CRS: WGS 84 / Pseudo-Mercator\n                               x\n1 POLYGON ((669987.2 6579597,...\n```\n:::\n\n```{.r .cell-code}\nloc.d <- cbind(st_coordinates(map)[, 1], st_coordinates(map)[, 2])\n#mesh <- inla.mesh.2d(loc=coo, max.edge = c(50000, 100000))\n#mesh <- inla.mesh.2d(loc.domain=loc.d)\nmesh <- inla.mesh.2d(loc.domain = loc.d, max.edge = c(50000, 100000), crs=crs(d))\nmesh\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfm_mesh_2d object:\n  CRS:\n    LegacyPROJ4:\t+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\n    WKT: (only shown with verbose = TRUE)\n  Manifold:\tR2\n  V / E / T:\t326 / 930 / 605\n  Euler char.:\t1\n  Constraints:\t45 boundary edges (1 group: 0), 56 interior edges (1 group: 0)\n  Bounding box: (243337.2,929462.1) x (6452354,7215241)\n  Basis d.o.f.:\t326\n```\n:::\n\n```{.r .cell-code}\nplot(mesh)\npoints(coo, col = \"red\")\naxis(1)\naxis(2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/mesh-1.png){width=672}\n:::\n\n```{.r .cell-code}\n(nv <- mesh$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 326\n```\n:::\n\n```{.r .cell-code}\n(n <- nrow(coo))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2705\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspde <- inla.spde2.matern(mesh = mesh, alpha = 2, constr = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbook.mesh.dual <- function(mesh) {\n    if (mesh$manifold=='R2') {\n        ce <- t(sapply(1:nrow(mesh$graph$tv), function(i)\n            colMeans(mesh$loc[mesh$graph$tv[i, ], 1:2])))\n        library(parallel)\n        pls <- mclapply(1:mesh$n, function(i) {\n            p <- unique(Reduce('rbind', lapply(1:3, function(k) {\n            j <- which(mesh$graph$tv[,k]==i)\n            if (length(j)>0) \n            return(rbind(ce[j, , drop=FALSE],\n            cbind(mesh$loc[mesh$graph$tv[j, k], 1] +\n            mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 1], \n            mesh$loc[mesh$graph$tv[j, k], 2] +\n            mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 2])/2))\n            else return(ce[j, , drop=FALSE])\n            })))\n            j1 <- which(mesh$segm$bnd$idx[,1]==i)\n            j2 <- which(mesh$segm$bnd$idx[,2]==i)\n            if ((length(j1)>0) | (length(j2)>0)) {\n            p <- unique(rbind(mesh$loc[i, 1:2], p,\n            mesh$loc[mesh$segm$bnd$idx[j1, 1], 1:2]/2 +\n            mesh$loc[mesh$segm$bnd$idx[j1, 2], 1:2]/2, \n            mesh$loc[mesh$segm$bnd$idx[j2, 1], 1:2]/2 +\n            mesh$loc[mesh$segm$bnd$idx[j2, 2], 1:2]/2))\n            yy <- p[,2]-mean(p[,2])/2-mesh$loc[i, 2]/2\n            xx <- p[,1]-mean(p[,1])/2-mesh$loc[i, 1]/2\n            }\n            else {\n            yy <- p[,2]-mesh$loc[i, 2]\n            xx <- p[,1]-mesh$loc[i, 1]\n            }\n            Polygon(p[order(atan2(yy,xx)), ])\n        })\n        return(SpatialPolygons(lapply(1:mesh$n, function(i)\n            Polygons(list(pls[[i]]), i))))\n    }\n    else stop(\"It only works for R2!\")\n}\ndmesh <- book.mesh.dual(mesh)\nplot(dmesh)\naxis(1)\naxis(2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/dual-mesh-1.png){width=672}\n:::\n:::\n\nWe then do something a little tricky. The mesh is larger than the domain that the points were observed in or the study region. So the intersections between the polygons in the mesh and the locations in $D$ are computed  \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(loc.d)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/mesh-process-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndomain.polys <- Polygons(list(Polygon(loc.d)), '0')\ndomainSP <- SpatialPolygons(list(domain.polys))\nplot(domainSP)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/mesh-process-2.png){width=672}\n:::\n\n```{.r .cell-code}\ndomain_sf <- st_as_sf(domainSP)\ncrs(domain_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\"\n```\n:::\n\n```{.r .cell-code}\ndomain_sf <- st_set_crs(domain_sf, projMercator)\nst_crs(domain_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: +proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs \n  wkt:\nPROJCRS[\"WGS 84 / Pseudo-Mercator\",\n    BASEGEOGCRS[\"WGS 84\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Popular Visualisation Pseudo Mercator\",\n            ID[\"EPSG\",1024]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"False easting\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n```\n:::\n\n```{.r .cell-code}\nplot(domain_sf)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/mesh-process-3.png){width=672}\n:::\n\n```{.r .cell-code}\nmesh_sf <- st_as_sf(dmesh)\nmesh_sf <- st_set_crs(mesh_sf, projMercator)\n# Check if the mesh polygons overlap with any of the locations \nw <- sapply(1:length(dmesh), function(i) {\n  if(length(st_intersects(mesh_sf[i,], domain_sf)[[1]])>0){\n    return(sf::st_area(sf::st_intersection(mesh_sf[i, ], domain_sf)))\n  }\n  else return(0)\n})\nsum(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 111060620373\n```\n:::\n\n```{.r .cell-code}\nst_area(map)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n111060620373 [m^2]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mesh)\nplot(domain_sf, add=T, col=\"green\")\npoints(mesh$loc[which(w > 0), 1:2], col = \"black\", pch = 20)\npoints(mesh$loc[which(w == 0), 1:2], col = \"red\", pch = 20)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/plot-mesh-1.png){width=672}\n:::\n:::\n\nTODO: January 13th. Okay, now i'm stuck again. Finish later\n\n::: {.cell}\n\n```{.r .cell-code}\ny.pp <- rep(0:1, c(nv, n))\ne.pp <- c(w, rep(0, n))\n# Projection matrix for the integration points (mesh vertices)\nA.int <- Diagonal(nv, rep(1, nv))\n# Projection matrix for observed points (event locations)\nA.y <- inla.spde.make.A(mesh = mesh, loc = coo)\n# Projection matrix for mesh vertices and event locations\nA.pp <- rbind(A.int, A.y)\n\n# We also create the projection matrix Ap.pp for the prediction locations.\nAp.pp <- inla.spde.make.A(mesh = mesh, loc = coop)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# stack for estimation\nstk.e.pp <- inla.stack(tag = \"est.pp\",\ndata = list(y = y.pp, e = e.pp), \nA = list(1, A.pp),\neffects = list(list(b0 = rep(1, nv + n)), list(s = 1:nv)))\n\n# stack for prediction stk.p\nstk.p.pp <- inla.stack(tag = \"pred.pp\",\ndata = list(y = rep(NA, nrow(coop)), e = rep(0, nrow(coop))),\nA = list(1, Ap.pp),\neffects = list(data.frame(b0 = rep(1, nrow(coop))),\n               list(s = 1:nv)))\n\n# stk.full has stk.e and stk.p\nstk.full.pp <- inla.stack(stk.e.pp, stk.p.pp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nformula <- y ~ 0 + b0 + f(s, model = spde)\nres <- inla(formula,  family = 'poisson',\n  data = inla.stack.data(stk.full.pp),\n  control.inla=list(int.strategy = 'grid', strategy=\"laplace\"),\n  control.predictor = list(compute = TRUE, link = 1,\n    A = inla.stack.A(stk.full.pp)),\n    E = inla.stack.data(stk.full.pp)$e)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres$summary.fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       mean       sd 0.025quant 0.5quant 0.975quant    mode          kld\nb0 1.039501 1.065052  -1.049386 1.039649   3.127548 1.03965 5.801275e-11\n```\n:::\n\n```{.r .cell-code}\nres$summary.hyperpar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  mean          sd 0.025quant   0.5quant 0.975quant       mode\nTheta1 for s   8.14040 0.001247988   8.137666   8.140495   8.142519   8.140964\nTheta2 for s -11.45034 0.009720901 -11.466856 -11.451076 -11.429055 -11.454715\n```\n:::\n\n```{.r .cell-code}\nindex <- inla.stack.index(stk.full.pp, tag = \"pred.pp\")$data\npred_mean <- res$summary.fitted.values[index, \"mean\"]\npred_ll <- res$summary.fitted.values[index, \"0.025quant\"]\npred_ul <- res$summary.fitted.values[index, \"0.975quant\"]\ngrid$mean <- NA\ngrid$ll <- NA\ngrid$ul <- NA\n\ngrid$mean[indicespointswithin] <- pred_mean\ngrid$ll[indicespointswithin] <- pred_ll\ngrid$ul[indicespointswithin] <- pred_ul\n```\n:::\n\nThen plot the predicted intensity\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(grid)\ngeom_sf(data=grid, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n:::\n\n\n\nWe have to make sure to get the domain for the sampler correct. The INLA code does it above, but inlabru by default does not.\n\nMore about that <https://inlabru-org.github.io/inlabru/articles/2d_lgcp_plotsampling.html>\nand actually the exact problem here: <https://groups.google.com/g/r-inla-discussion-group/c/0bBC9bVV-L4> even though the problem was with preferential sampling. In the mesh-process R section above, you can see the manipulation to get the domains correct for INLA. Even with including ```sampler=domain_sf``` here, the estimates are not exactly the same as INLA, but closer than it was before.\n\nTODO: What is this domain stuff for exactly? The integration? Should be equation 3 of Simpson (2016).\n\n::: {.cell}\n\n```{.r .cell-code}\n# TODO: Make sure I get the same result as inla. Options and mesh are off\n# Oh nice we can name the intercept but then need to subtract 1 to get rid of the default intercept\nformula_inlabru <- geometry ~ b0(1) - 1 + f(geometry, model = spde)\nfit1 <- lgcp(formula_inlabru, data=d, sampler=domain_sf, domain = list(geometry = mesh), \n             options = list(control.inla=list(int.strategy = 'ccd', strategy=\"laplace\")))\n#                          control.compute=list(config=TRUE),\n#                          control.results=list(return.marginals.random = TRUE,\n#                                               return.marginals.predictor = TRUE),\n#                          control.predictor = list(compute = TRUE)))\n\nsummary(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.12.0\nINLA version: 24.05.01-1\nComponents:\nb0: main = linear(1), group = exchangeable(1L), replicate = iid(1L), NULL\nf: main = spde(geometry), group = exchangeable(1L), replicate = iid(1L), NULL\nLikelihoods:\n  Family: 'cp'\n    Tag: ''\n    Data class: 'sf', 'data.frame'\n    Response class: 'numeric'\n    Predictor: geometry ~ .\n    Used components: effects[b0, f], latent[]\nTime used:\n    Pre = 0.691, Running = 1.47, Post = 0.175, Total = 2.33 \nFixed effects:\n      mean  sd 0.025quant 0.5quant 0.975quant   mode kld\nb0 -21.688 1.4    -24.492  -21.662    -19.041 -21.66   0\n\nRandom effects:\n  Name\t  Model\n    f SPDE2 model\n\nModel hyperparameters:\n               mean    sd 0.025quant 0.5quant 0.975quant   mode\nTheta1 for f   8.85 0.106       8.66     8.85       9.07   8.83\nTheta2 for f -12.74 0.873     -14.74   -12.63     -11.41 -12.07\n\nDeviance Information Criterion (DIC) ...............: -126820.99\nDeviance Information Criterion (DIC, saturated) ....: NA\nEffective number of parameters .....................: -127802.62\n\nWatanabe-Akaike information criterion (WAIC) ...: 7199.81\nEffective number of parameters .................: 2414.72\n\nMarginal log-Likelihood:  -64580.42 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\nTODO: Oh wow, why is b0 so different between inla and inlabru.\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions1 <- predict(fit1, newdata=dp, formula = ~ b0 + f)\npredictions2 <- predict(fit1, newdata=dp, formula = ~ f)\nggplot() +\ngeom_sf(data=predictions1, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/preds-intensity-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Check the contribution of just the spatial field\nggplot() +\ngeom_sf(data=predictions2, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_lgcp_tutorial_netherlands_data_files/figure-html/preds-intensity-2.png){width=672}\n:::\n:::\n\n\n\n\nThen, we can move onto multiple likelihoods and inlabru\n",
    "supporting": [
      "inla_inlabru_lgcp_tutorial_netherlands_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}