{
  "hash": "961800421c34d6975a27870b01da613e",
  "result": {
    "markdown": "\n# Spatial modelling with INLA and SPDE\n\nHaving covered the need-to-know material for INLA and SPDE, next I'm going to build a spatial model using both ```INLA``` and ```inlabru```. Comparing the two packages is useful because, though they can be expected to give the same results in most cases, the implementation is a bit different. Knowing when using the more complicated ```INLA``` can be justified is a useful exercise, I think. \n\nThe model fit here is a simple geostatistical one:\n$$\nY_i \\sim N(u_i, \\sigma^2)\\\\\nu_i = \\beta_0\\cdot\\text{temp} + \\beta_1\\cdot\\text{precipitation}_i + S(x_i).\n$$\nSo it's a typical Gaussian distributed variable with underlying latent structure, or otherwise referred to as a random effect modelled as a Gaussian process that is spatially indexed. In either case, it represents measurements taken at discrete locations but used to describe or estimate a spatially continuous process, such as air pollution. \n\nLet's get straight to data downloading and processing. I downloaded air pollution data in the Netherlands for the year of 2023 from <https://eeadmz1-downloads-webapp.azurewebsites.net/>.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(INLA)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sp\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is INLA_24.05.01-1 built 2024-05-01 18:49:50 UTC.\n - See www.r-inla.org/contact-us for how to get help.\n - List available models/likelihoods/etc with inla.list.models()\n - Use inla.doc(<NAME>) to access documentation\n```\n:::\n\n```{.r .cell-code}\nlibrary(inlabru)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: fmesher\n```\n:::\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.11.2, GDAL 3.8.2, PROJ 9.3.1; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nlibrary(rnaturalearth)\nlibrary(ggplot2)\nlibrary(viridis)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: viridisLite\n```\n:::\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nterra 1.7.78\n```\n:::\n\n```{.r .cell-code}\nlibrary(arrow)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'arrow'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:terra':\n\n    buffer\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:utils':\n\n    timestamp\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:terra':\n\n    intersect, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(readr)\n#data_path <- file.path(\"D:\", \"data\", \"air_quality_data\", \"belgium_eea\", \"E1a\")\ndata_path <- file.path(\"D:\", \"data\", \"air_quality_data\", \"netherlands_eea\", \"E1a\")\nd <- open_dataset(data_path)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFileSystemDataset with 199 Parquet files\n12 columns\nSamplingpoint: string\nPollutant: int32\nStart: timestamp[ns] not null\nEnd: timestamp[ns] not null\nValue: decimal128(38, 18)\nUnit: string\nAggType: string\nValidity: int32 not null\nVerification: int32 not null\nResultTime: timestamp[ns] not null\nDataCapture: decimal128(38, 18)\nFkObservationLog: string\n```\n:::\n\n```{.r .cell-code}\n# 8\tNitrogen dioxide\n# 5\tParticulate matter < 10 µm\n# 6001\tParticulate matter < 2.5 µm\nd %>% group_by(Samplingpoint) |> filter(Pollutant==6001, Value>-1) |> collect() -> df\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 442,873 × 12\n# Groups:   Samplingpoint [53]\n   Samplingpoint   Pollutant Start               End                 Value Unit \n   <chr>               <int> <dttm>              <dttm>              <dbl> <chr>\n 1 NL/SPO-NL00007…      6001 2023-01-01 01:00:00 2023-01-01 02:00:00 131.  ug.m…\n 2 NL/SPO-NL00007…      6001 2023-01-01 02:00:00 2023-01-01 03:00:00  86.2 ug.m…\n 3 NL/SPO-NL00007…      6001 2023-01-01 03:00:00 2023-01-01 04:00:00  30.7 ug.m…\n 4 NL/SPO-NL00007…      6001 2023-01-01 04:00:00 2023-01-01 05:00:00  11   ug.m…\n 5 NL/SPO-NL00007…      6001 2023-01-01 05:00:00 2023-01-01 06:00:00   9.1 ug.m…\n 6 NL/SPO-NL00007…      6001 2023-01-01 06:00:00 2023-01-01 07:00:00   5.3 ug.m…\n 7 NL/SPO-NL00007…      6001 2023-01-01 07:00:00 2023-01-01 08:00:00   2.8 ug.m…\n 8 NL/SPO-NL00007…      6001 2023-01-01 08:00:00 2023-01-01 09:00:00   2.3 ug.m…\n 9 NL/SPO-NL00007…      6001 2023-01-01 10:00:00 2023-01-01 11:00:00  -0.6 ug.m…\n10 NL/SPO-NL00007…      6001 2023-01-01 11:00:00 2023-01-01 12:00:00   1.4 ug.m…\n# ℹ 442,863 more rows\n# ℹ 6 more variables: AggType <chr>, Validity <int>, Verification <int>,\n#   ResultTime <dttm>, DataCapture <dbl>, FkObservationLog <chr>\n```\n:::\n:::\n\nAdd locations to the sampling stations.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 442,873 × 12\n# Groups:   Samplingpoint [53]\n   Samplingpoint   Pollutant Start               End                 Value Unit \n   <chr>               <int> <dttm>              <dttm>              <dbl> <chr>\n 1 NL/SPO-NL00007…      6001 2023-01-01 01:00:00 2023-01-01 02:00:00 131.  ug.m…\n 2 NL/SPO-NL00007…      6001 2023-01-01 02:00:00 2023-01-01 03:00:00  86.2 ug.m…\n 3 NL/SPO-NL00007…      6001 2023-01-01 03:00:00 2023-01-01 04:00:00  30.7 ug.m…\n 4 NL/SPO-NL00007…      6001 2023-01-01 04:00:00 2023-01-01 05:00:00  11   ug.m…\n 5 NL/SPO-NL00007…      6001 2023-01-01 05:00:00 2023-01-01 06:00:00   9.1 ug.m…\n 6 NL/SPO-NL00007…      6001 2023-01-01 06:00:00 2023-01-01 07:00:00   5.3 ug.m…\n 7 NL/SPO-NL00007…      6001 2023-01-01 07:00:00 2023-01-01 08:00:00   2.8 ug.m…\n 8 NL/SPO-NL00007…      6001 2023-01-01 08:00:00 2023-01-01 09:00:00   2.3 ug.m…\n 9 NL/SPO-NL00007…      6001 2023-01-01 10:00:00 2023-01-01 11:00:00  -0.6 ug.m…\n10 NL/SPO-NL00007…      6001 2023-01-01 11:00:00 2023-01-01 12:00:00   1.4 ug.m…\n# ℹ 442,863 more rows\n# ℹ 6 more variables: AggType <chr>, Validity <int>, Verification <int>,\n#   ResultTime <dttm>, DataCapture <dbl>, FkObservationLog <chr>\n```\n:::\n\n```{.r .cell-code}\ndf <- df %>%\n   #mutate(Samplingpoint = str_remove(Samplingpoint, \"BE/\"))\n   mutate(Samplingpoint = str_remove(Samplingpoint, \"NL/\"))\n#station_location_path <- file.path(\"D:\", \"data\", \"air_quality_data\", \"eea_stations_2023\", \"belgium_stations_2023.csv\")\nstation_location_path <- file.path(\"D:\", \"data\", \"air_quality_data\", \"eea_stations_2023\", \"nl_stations_2023.csv\")\nstation_locations <- read_csv(station_location_path)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 4685 Columns: 27\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (19): Country, Air Quality Network, Air Quality Network Name, Air Qualit...\ndbl  (8): Year, Air Pollution Level, Data Coverage, Verification, Longitude,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nstation_locations <- rename(station_locations, Samplingpoint = 'Sampling Point Id')\nstation_locations %>% \n  distinct(Samplingpoint, Longitude, Latitude) -> unique_locations\nmerged_df <- df %>% \n  left_join(unique_locations %>% select(Samplingpoint, Longitude, Latitude), by = \"Samplingpoint\")\nmerged_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 442,873 × 14\n# Groups:   Samplingpoint [53]\n   Samplingpoint   Pollutant Start               End                 Value Unit \n   <chr>               <int> <dttm>              <dttm>              <dbl> <chr>\n 1 SPO-NL00007_06…      6001 2023-01-01 01:00:00 2023-01-01 02:00:00 131.  ug.m…\n 2 SPO-NL00007_06…      6001 2023-01-01 02:00:00 2023-01-01 03:00:00  86.2 ug.m…\n 3 SPO-NL00007_06…      6001 2023-01-01 03:00:00 2023-01-01 04:00:00  30.7 ug.m…\n 4 SPO-NL00007_06…      6001 2023-01-01 04:00:00 2023-01-01 05:00:00  11   ug.m…\n 5 SPO-NL00007_06…      6001 2023-01-01 05:00:00 2023-01-01 06:00:00   9.1 ug.m…\n 6 SPO-NL00007_06…      6001 2023-01-01 06:00:00 2023-01-01 07:00:00   5.3 ug.m…\n 7 SPO-NL00007_06…      6001 2023-01-01 07:00:00 2023-01-01 08:00:00   2.8 ug.m…\n 8 SPO-NL00007_06…      6001 2023-01-01 08:00:00 2023-01-01 09:00:00   2.3 ug.m…\n 9 SPO-NL00007_06…      6001 2023-01-01 10:00:00 2023-01-01 11:00:00  -0.6 ug.m…\n10 SPO-NL00007_06…      6001 2023-01-01 11:00:00 2023-01-01 12:00:00   1.4 ug.m…\n# ℹ 442,863 more rows\n# ℹ 8 more variables: AggType <chr>, Validity <int>, Verification <int>,\n#   ResultTime <dttm>, DataCapture <dbl>, FkObservationLog <chr>,\n#   Longitude <dbl>, Latitude <dbl>\n```\n:::\n\n```{.r .cell-code}\nstation_locations_sf <- st_as_sf(station_locations, coords = c(\"Longitude\", \"Latitude\"))\nair_sf <- st_as_sf(merged_df, coords = c(\"Longitude\", \"Latitude\"))\nst_crs(air_sf) <- \"EPSG:4326\"\nair_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 442873 features and 12 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.8386 ymin: 50.888 xmax: 6.9195 ymax: 53.3304\nGeodetic CRS:  WGS 84\n# A tibble: 442,873 × 13\n# Groups:   Samplingpoint [53]\n   Samplingpoint   Pollutant Start               End                 Value Unit \n * <chr>               <int> <dttm>              <dttm>              <dbl> <chr>\n 1 SPO-NL00007_06…      6001 2023-01-01 01:00:00 2023-01-01 02:00:00 131.  ug.m…\n 2 SPO-NL00007_06…      6001 2023-01-01 02:00:00 2023-01-01 03:00:00  86.2 ug.m…\n 3 SPO-NL00007_06…      6001 2023-01-01 03:00:00 2023-01-01 04:00:00  30.7 ug.m…\n 4 SPO-NL00007_06…      6001 2023-01-01 04:00:00 2023-01-01 05:00:00  11   ug.m…\n 5 SPO-NL00007_06…      6001 2023-01-01 05:00:00 2023-01-01 06:00:00   9.1 ug.m…\n 6 SPO-NL00007_06…      6001 2023-01-01 06:00:00 2023-01-01 07:00:00   5.3 ug.m…\n 7 SPO-NL00007_06…      6001 2023-01-01 07:00:00 2023-01-01 08:00:00   2.8 ug.m…\n 8 SPO-NL00007_06…      6001 2023-01-01 08:00:00 2023-01-01 09:00:00   2.3 ug.m…\n 9 SPO-NL00007_06…      6001 2023-01-01 10:00:00 2023-01-01 11:00:00  -0.6 ug.m…\n10 SPO-NL00007_06…      6001 2023-01-01 11:00:00 2023-01-01 12:00:00   1.4 ug.m…\n# ℹ 442,863 more rows\n# ℹ 7 more variables: AggType <chr>, Validity <int>, Verification <int>,\n#   ResultTime <dttm>, DataCapture <dbl>, FkObservationLog <chr>,\n#   geometry <POINT [°]>\n```\n:::\n:::\n\nThen examine the time series\n\n::: {.cell}\n\n```{.r .cell-code}\ndistinct_stations <- unique(air_sf$Samplingpoint)[1:12]\nplotting_stations <- air_sf[air_sf$Samplingpoint%in%distinct_stations,]\nplotting_stations %>% \n  ggplot(aes(x=Start, y=Value)) + \n    geom_line() + \n    facet_wrap(~ Samplingpoint) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    labs(title = \"Time series of monitoring stations\", x = \"Time, hourly\", y = \"Conc (μg/m³)\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/plot-time-series-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nair_sf <- air_sf %>% filter(Start==as.POSIXct(\"2023-01-01 16:00:00\t\"))\n```\n:::\n\n\nThen let's load a map of the Netherlands. The border is from <https://service.pdok.nl/kadaster/bestuurlijkegrenzen/atom/bestuurlijke_grenzen.xml>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap <- st_read(file.path(\"D:\", \"data\", \"maps\", \"netherlands_bestuurlijkegrenzen_2021\", \"bestuurlijkegrenzen.gpkg\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMultiple layers are present in data source D:\\data\\maps\\netherlands_bestuurlijkegrenzen_2021\\bestuurlijkegrenzen.gpkg, reading layer `gemeenten'.\nUse `st_layers' to list all layer names and their type in a data source.\nSet the `layer' argument in `st_read' to read a particular layer.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `gemeenten' from data source \n  `D:\\data\\maps\\netherlands_bestuurlijkegrenzen_2021\\bestuurlijkegrenzen.gpkg' \n  using driver `GPKG'\nSimple feature collection with 352 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 10425.16 ymin: 306846.2 xmax: 278026.1 ymax: 621876.3\nProjected CRS: Amersfoort / RD New\n```\n:::\n\n```{.r .cell-code}\nmap <- st_union(map)\nmap <- st_as_sf(map)\nmap <- st_transform(map, crs = st_crs(air_sf))\n# raster grid covering map\ngrid <- terra::rast(map, nrows = 100, ncols = 100)\n# coordinates of all cells\nxy <- terra::xyFromCell(grid, 1:ncell(grid))\n# transform points to a sf object\ndp <- st_as_sf(as.data.frame(xy), coords = c(\"x\", \"y\"),\n                 crs = st_crs(map))\n\n# indices points within the map\nindicespointswithin <- which(st_intersects(dp, map,\n                                           sparse = FALSE))\n\n# points within the map\ndp <- st_filter(dp, map)\n\n# plot\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-maps-1.png){width=672}\n:::\n:::\n\nMore data process\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geodata)\n# With geodata library\nsave_path <- file.path(\"D:\", \"data\", \"air_quality_data\", \"aux_variables\")\ncovtemp <- worldclim_global(var = \"tavg\", res = 10,\n                            path = save_path)\ncovprec <- worldclim_global(var = \"prec\", res = 10,\n                            path = save_path)\n# Extract at observed locations\nair_sf$covtemp <- extract(mean(covtemp), st_coordinates(air_sf))[, 1]\nair_sf$covprec <- extract(mean(covprec), st_coordinates(air_sf))[, 1]\n# Extract at prediction locations\ndp$covtemp <- extract(mean(covtemp), st_coordinates(dp))[, 1]\ndp$covprec <- extract(mean(covprec), st_coordinates(dp))[, 1]\n\nggplot() + geom_sf(data = map) +\n  geom_sf(data = air_sf, aes(col = Value)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-data-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot() + geom_sf(data = map) +\n  geom_sf(data = air_sf, aes(col = covtemp)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-data-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot() + geom_sf(data = map) +\n  geom_sf(data = air_sf, aes(col = covprec)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-data-2-3.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp, aes(col = covtemp)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-data-2-4.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp, aes(col = covprec)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/process-data-2-5.png){width=672}\n:::\n:::\n\n\nLooks like there is a couple of nans in there. Let's impute using the mean.\n\n::: {.cell}\n\n```{.r .cell-code}\ndp <- dp %>% mutate(covprec=ifelse(is.na(covprec), mean(covprec, na.rm=TRUE), covprec),\n                    covtemp=ifelse(is.na(covtemp), mean(covtemp, na.rm=TRUE), covtemp))\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp, aes(col = covtemp)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/imputation-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot() + geom_sf(data = map) +\n  geom_sf(data = dp, aes(col = covprec)) +\n  scale_color_viridis()\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/imputation-2.png){width=672}\n:::\n:::\n\nSaw in the forum <https://groups.google.com/g/r-inla-discussion-group/c/z_v2oIh2egs> it's good to work with units of kilometers which is intuitive from previous spatial data work.\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(\"EPSG:3857\")$proj4string\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"\n```\n:::\n\n```{.r .cell-code}\nprojMercator<-\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0\n+x_0=0 +y_0=0 +k=1 +units=km +nadgrids=@null +wktext +no_defs\"\nair_sf_project <- st_transform(air_sf, crs = projMercator)\ndp <- st_transform(dp, crs = projMercator)\n# Observed coordinates\ncoo <- st_coordinates(air_sf_project)\n\n# Predicted coordinates\ncoop <- st_coordinates(dp)\nsummary(dist(coo)) # summary of distances between locations\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n  0.5852  70.0344 109.2560 131.9875 179.8815 472.4047 \n```\n:::\n:::\n\nMesh options are from <https://punama.github.io/BDI_INLA/#:~:text=stack%20function.,list%20of%20effects%20(effects).>\n```max.edge``` controls the largest triangle edge length, and providing it with a vector ```c(inner, outer)``` sets the max edge for inside the boundary and outside the boundary. The purpose of this is to avoid boundary effects in the estimation of the model, where boundary values have high variance. Lindgren and Rue (2015) suggest to extend the domain by some amount. This is briefly discussed in the book by Blangiardo (2015).\n\n```cutoff``` is the minimum allowed distance between points. Otherwise, points are replaced by a single vertex. For areas of high clusters of points, this could be useful to reduce redundancy. If no ```boundary``` is set the mesh is created on the convex hull of the observations.\n\nThis was inspired from <https://punama.github.io/BDI_INLA/>. Thanks!\n::: {.cell}\n\n```{.r .cell-code}\nmesh0 <- inla.mesh.2d(loc = coo, max.edge=c(200, 500))\nmesh1 <- inla.mesh.2d(loc = coo, max.edge=c(200, 500), cutoff=1)\nmesh2 <- inla.mesh.2d(loc = coo, max.edge=c(100, 150), cutoff=1)\nmesh3 <- inla.mesh.2d(loc = coo, max.edge=c(100), cutoff=1)\nmesh4 <- inla.mesh.2d(loc = coo, max.edge=c(500, 750))\nmesh5 <- inla.mesh.2d(loc = coo, max.edge=c(500, 750), cutoff=1)\nplot(mesh0)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(mesh1)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(mesh2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(mesh3)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-4.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(mesh4)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-5.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(mesh5)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-mesh-6.png){width=672}\n:::\n\n```{.r .cell-code}\n# Using mesh0\nmesh <-inla.mesh.2d(loc = coo, max.edge=c(200, 500), crs=st_crs(air_sf_project))\n```\n:::\n\nNext we construct the A matrix that \"A that projects the GRF from the observations to the vertices of the triangulated mesh.\" (Moraga 2024). \nThis A matrix has a row for each ovservation, and columns equal to the number of vertices in the mesh. That is shown above, with ```mesh$n```. Below, two different meshes are generated. One for the observation locations, and one for the prediction locations. We need to set these both at once, because to make predictions in INLA we have to have that all pre-specified, unlike with the typical modelling style in R.\n\nAdditionally, the index allows us to extract fitted values from the model.\n\nThe smoothness parameter is set to 1, where in the spatial case $d=2$ and $\\alpha=\\nu + d/2 = 2$, seen in the code below.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mesh)\npoints(coo, col = \"red\")\naxis(1)\naxis(2)\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inla-A-1.png){width=672}\n:::\n\n```{.r .cell-code}\nspde <- inla.spde2.matern(mesh = mesh, alpha = 2, constr = TRUE)\nindexs <- inla.spde.make.index(\"s\", spde$n.spde)\nlengths(indexs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      s s.group  s.repl \n    280     280     280 \n```\n:::\n\n```{.r .cell-code}\n# Make the projection matrices\nA <- inla.spde.make.A(mesh = mesh, loc = coo)\nAp <- inla.spde.make.A(mesh = mesh, loc = coop)\ndim(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  52 280\n```\n:::\n\n```{.r .cell-code}\ndim(Ap)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4944  280\n```\n:::\n:::\nThen we have to make the INLA stack. This is done because we need to combine the data for estimation with the prediction data, as well as the projection matrices. It contains the response data, the list of covariate data--here the temperature and precipitation--the projection matrices, and the indices.\n\n::: {.cell}\n\n```{.r .cell-code}\n# stack for estimation stk.e\nstk.e <- inla.stack(tag = \"est\",\ndata = list(y = air_sf_project$Value), A = list(1, A),\neffects = list(data.frame(b0 = rep(1, nrow(A)),\ncovtemp = air_sf_project$covtemp, covprec = air_sf_project$covprec),\ns = indexs))\n#stk.e\n\n# stack for prediction stk.p\nstk.p <- inla.stack(tag = \"pred\",\ndata = list(y = NA), A = list(1, Ap),\neffects = list(data.frame(b0 = rep(1, nrow(Ap)),\ncovtemp = dp$covtemp, covprec = dp$covprec),\ns = indexs))\n#stk.p\n\n# stk.full has stk.e and stk.p\nstk.full <- inla.stack(stk.e, stk.p)\n```\n:::\nFinally, we can specify the model in INLA. All the hard work has been done above and at least the model specification in INLA is easier. This model has mean specified by\n$$\n\\mu_i = \\beta_0 + \\beta_1 \\times \\text{temp}_i + \\beta_2 \\times \\text{prec}_i + S(x_i),\n$$\nso there is some contribution from fixed effects as well as a unknown latent process modelled as a zero-mean Gaussian Random Field with Matern covariance function. This puts us well within INLA territory. The model equation can be seen quite clearly in the ```formula``` variable below.\n\n::: {.cell}\n\n```{.r .cell-code}\nformula <- y ~ 0 + b0 + covtemp + covprec + f(s, model = spde)\nres <- inla(formula, family = \"gaussian\",\n       data = inla.stack.data(stk.full),\n       control.predictor = list(compute = TRUE,\n                                A = inla.stack.A(stk.full)),\n       control.compute = list(return.marginals.predictor = TRUE))\n```\n:::\nNotice that I am passing a few options to the ```inla``` call. Importantly, ```control.compute```. We have a nice description of the control options at <https://becarioprecario.bitbucket.io/inla-gitbook/ch-INLA.html#sec:controlops>. It controls what quantities are actually computed and returned during the INLA estimation. For example, there are a few different information criteria that it can return.\n\n```control.predictor``` will compute the posterior marginals of the parameters.\n\nThe options:\n::: {.cell}\n\n```{.r .cell-code}\ninla.set.control.compute.default()\n```\n:::\nOnce the model is fit, we can inspect the fixed parameters and estimated latent field, as well as the hyperparameters for the latent field.\n::: {.cell}\n\n```{.r .cell-code}\nres$summary.fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                mean         sd  0.025quant     0.5quant 0.975quant\nb0      -15.29769449 21.3472624 -57.7595559 -15.17245556 26.4583704\ncovtemp   2.17003514  2.0949918  -1.8002534   2.09513247  6.5392273\ncovprec  -0.01550201  0.2034683  -0.4214077  -0.01404086  0.3818577\n                mode          kld\nb0      -15.17140288 4.819848e-08\ncovtemp   2.09359434 3.231952e-07\ncovprec  -0.01411427 5.717319e-08\n```\n:::\n\n```{.r .cell-code}\n# Latent field is here\n# res$summary.random$s\n# res$summary.hyperpar\n\nindex <- inla.stack.index(stack = stk.full, tag = \"pred\")$data\npred_mean <- res$summary.fitted.values[index, \"mean\"]\npred_ll <- res$summary.fitted.values[index, \"0.025quant\"]\npred_ul <- res$summary.fitted.values[index, \"0.975quant\"]\ngrid$mean <- NA\ngrid$ll <- NA\ngrid$ul <- NA\n\nlength(pred_mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4944\n```\n:::\n\n```{.r .cell-code}\nlength(indicespointswithin)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4944\n```\n:::\n\n```{.r .cell-code}\ngrid$mean[indicespointswithin] <- pred_mean\ngrid$ll[indicespointswithin] <- pred_ll\ngrid$ul[indicespointswithin] <- pred_ul\n  \nsummary(grid) # negative values for the lower limit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mean             ll               ul        \n Min.   :1.338   Min.   :-4.722   Min.   : 3.733  \n 1st Qu.:3.626   1st Qu.: 0.359   1st Qu.: 6.530  \n Median :4.665   Median : 1.462   Median : 7.813  \n Mean   :4.595   Mean   : 1.368   Mean   : 7.874  \n 3rd Qu.:5.553   3rd Qu.: 2.405   3rd Qu.: 9.087  \n Max.   :8.316   Max.   : 6.753   Max.   :12.860  \n NA's   :5056    NA's   :5056     NA's   :5056    \n```\n:::\n\n```{.r .cell-code}\nlibrary(rasterVis)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: lattice\n```\n:::\n\n```{.r .cell-code}\nlevelplot(grid, layout = c(1, 3),\nnames.attr = c(\"Mean\", \"2.5 percentile\", \"97.5 percentile\"))\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/inspect-fit-1.png){width=672}\n:::\n:::\n\nWhen ```compute=TRUE``` in ```control.predictor```, we can also obtain the output below. <https://www.paulamoraga.com/book-geospatial/sec-inla.html> is good for info about this.\n::: {.cell}\n\n```{.r .cell-code}\nres$summary.fitted.values\nres$summary.linear.predictor\n```\n:::\nas well as ```marginals.linear.predictor``` and ```marginals.fitted.values```.\n\nFrom <https://becarioprecario.bitbucket.io/inla-gitbook/ch-INLA.html#model-fitting-strategies> \nwe can also see the differences using the different fitting strategies, set by the ```control.inla``` argument.\n\nWe can change both the Gaussian approximation strategy for the posterior full conditional distributions, as well as the integration strategy used to integrate out the $\\theta_{-k}$ parameters to get the marginal distribution for $\\theta_k$. \n\nThe ```\"grid\"``` option is the most costly, compared to the central composite design (```\"ccd\"```). In the empirical bayes option (```\"eb\"```), the posterior mode is used as the integration point.\n\n::: {.cell}\n\n```{.r .cell-code}\napprox_strategy <- c(\"gaussian\", \"simplified.laplace\", \"laplace\")\nint_strategy <- c(\"ccd\", \"grid\", \"eb\")\nmodels <- c(\"iid\", \"matern\")\nfits <- matrix(nrow=length(approx_strategy)*length(int_strategy)*length(models), ncol=3)\nfits_marginals <- vector(mode=\"list\", length=length(approx_strategy)*length(int_strategy)*length(models))\nindex_f <- 0\nmodel_names <- c()\nfor (m in models){\n  for(a in approx_strategy){\n    for (i in int_strategy){\n      index_f <- index_f + 1\n      if (m==\"matern\"){\n        formula_approx <- y ~ 0 + b0 + covtemp + covprec + f(s, model = spde)\n      }\n      else{\n        formula_approx <- y ~ 0 + b0 + covtemp + covprec + f(s, model = \"iid\")\n      }\n      print(paste(a, \", \", i, \", \", m))\n      model_names <- c(model_names, paste(a, \", \", i, \", \", m))\n      fit_approx <- inla(formula, family = \"gaussian\",\n         data = inla.stack.data(stk.full),\n         control.inla = list(strategy = a, int.strategy = i),\n         control.compute = list(cpo = TRUE, dic = TRUE, waic = TRUE),\n         control.predictor = list(compute = TRUE, A = inla.stack.A(stk.full)))\n      fits[index_f,] <- fit_approx$summary.fixed$mean\n      fits_marginals[[index_f]] <- fit_approx$marginals.fixed$b0\n  }\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"gaussian ,  ccd ,  iid\"\n[1] \"gaussian ,  grid ,  iid\"\n[1] \"gaussian ,  eb ,  iid\"\n[1] \"simplified.laplace ,  ccd ,  iid\"\n[1] \"simplified.laplace ,  grid ,  iid\"\n[1] \"simplified.laplace ,  eb ,  iid\"\n[1] \"laplace ,  ccd ,  iid\"\n[1] \"laplace ,  grid ,  iid\"\n[1] \"laplace ,  eb ,  iid\"\n[1] \"gaussian ,  ccd ,  matern\"\n[1] \"gaussian ,  grid ,  matern\"\n[1] \"gaussian ,  eb ,  matern\"\n[1] \"simplified.laplace ,  ccd ,  matern\"\n[1] \"simplified.laplace ,  grid ,  matern\"\n[1] \"simplified.laplace ,  eb ,  matern\"\n[1] \"laplace ,  ccd ,  matern\"\n[1] \"laplace ,  grid ,  matern\"\n[1] \"laplace ,  eb ,  matern\"\n```\n:::\n:::\nLet's compare the means of the parameters\n::: {.cell}\n\n```{.r .cell-code}\nfits_df <- as.data.frame(fits)\nnames(fits_df) <- c(\"b0\", \"covtemp\", \"covprec\")\nfits_df$models <- model_names\nfits_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          b0  covtemp     covprec                               models\n1  -13.85789 2.049883 -0.01973532               gaussian ,  ccd ,  iid\n2  -15.29769 2.170035 -0.01550201              gaussian ,  grid ,  iid\n3  -13.11329 1.992509 -0.02262044                gaussian ,  eb ,  iid\n4  -13.85789 2.049883 -0.01973532     simplified.laplace ,  ccd ,  iid\n5  -15.29769 2.170035 -0.01550201    simplified.laplace ,  grid ,  iid\n6  -13.11329 1.992509 -0.02262044      simplified.laplace ,  eb ,  iid\n7  -13.85789 2.049883 -0.01973532                laplace ,  ccd ,  iid\n8  -15.29769 2.170035 -0.01550201               laplace ,  grid ,  iid\n9  -13.11329 1.992509 -0.02262044                 laplace ,  eb ,  iid\n10 -13.85789 2.049883 -0.01973532            gaussian ,  ccd ,  matern\n11 -15.29769 2.170035 -0.01550201           gaussian ,  grid ,  matern\n12 -13.11329 1.992509 -0.02262044             gaussian ,  eb ,  matern\n13 -13.85789 2.049883 -0.01973532  simplified.laplace ,  ccd ,  matern\n14 -15.29769 2.170035 -0.01550201 simplified.laplace ,  grid ,  matern\n15 -13.11329 1.992509 -0.02262044   simplified.laplace ,  eb ,  matern\n16 -13.85789 2.049883 -0.01973532             laplace ,  ccd ,  matern\n17 -15.29769 2.170035 -0.01550201            laplace ,  grid ,  matern\n18 -13.11329 1.992509 -0.02262044              laplace ,  eb ,  matern\n```\n:::\n:::\nAlso compare the posteriors themselves\n::: {.cell}\n\n```{.r .cell-code}\n# Combine dataframes\ndf_list <- lapply(fits_marginals, function(m) {\n  data.frame(x = m[,1], y = m[,2]) \n})\nnew_df <- do.call(rbind, df_list) \n# Add an ID column\nrow_counts <- sapply(fits_marginals, nrow)\nids <- factor(rep(1:length(fits_marginals), each = row_counts))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rep(1:length(fits_marginals), each = row_counts): first element used\nof 'each' argument\n```\n:::\n\n```{.r .cell-code}\nnew_df$id <- ids\nlength(ids)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 774\n```\n:::\n\n```{.r .cell-code}\nnew_df <- new_df[1:86,]\nggplot(new_df, aes(x = x, y = y, colour = id)) + \n  geom_line() \n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/compare-marginals-1.png){width=672}\n:::\n:::\nWow so with this data set there is not really much different between meshes or with estimation methods.\n\nAnother useful feature is the set of functions that can be used to manipulate the marginal distributions. Might be useful to compute posterior quantities such as KL divergence: <https://becarioprecario.bitbucket.io/inla-gitbook/ch-INLA.html#sec:marginals>\n\nAgain from <https://www.paulamoraga.com/book-geospatial/sec-inla.html> is helpful.\n\n::: {.cell}\n\n```{.r .cell-code}\ninla.mmarginal(res$marginals.fixed$b0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -14.90955\n```\n:::\n\n```{.r .cell-code}\n# Should be the same?\nres$summary.fixed$mode[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -15.1714\n```\n:::\n:::\nNext, let's write that model in INLABRU and check if the estimates are the same. Then, we also look at how to fit the LGCP in INLA/INLABRU. \n\nWne can use the same mesh and spde function as we used before. And also the same formula! (I think). But what is especially nice about INLABRU is that we don't have to set up the stack with the projection matrices. We just model the response variable as a function of the covariates in the dataset we set up earlier and the locations of the observations. In INLABRU, we can use the sf dataset object directly.\n\nINLA \n::: {.cell}\n\n```{.r .cell-code}\nformula <- Value ~ Intercept(1) + covtemp + covprec + f(geometry, model = spde)\n# Fit the model for inlabru\nfit <- bru(formula, data = air_sf_project, family = \"gaussian\")\n# Summarize the results\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.12.0\nINLA version: 24.05.01-1\nComponents:\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L), NULL\ncovtemp: main = linear(covtemp), group = exchangeable(1L), replicate = iid(1L), NULL\ncovprec: main = linear(covprec), group = exchangeable(1L), replicate = iid(1L), NULL\nf: main = spde(geometry), group = exchangeable(1L), replicate = iid(1L), NULL\nLikelihoods:\n  Family: 'gaussian'\n    Tag: ''\n    Data class: 'sf', 'grouped_df', 'tbl_df', 'tbl', 'data.frame'\n    Response class: 'numeric'\n    Predictor: Value ~ .\n    Used components: effects[Intercept, covtemp, covprec, f], latent[]\nTime used:\n    Pre = 0.8, Running = 0.685, Post = 0.29, Total = 1.77 \nFixed effects:\n             mean     sd 0.025quant 0.5quant 0.975quant    mode kld\nIntercept -15.298 21.347    -57.760  -15.172     26.458 -15.171   0\ncovtemp     2.170  2.095     -1.800    2.095      6.539   2.094   0\ncovprec    -0.016  0.203     -0.421   -0.014      0.382  -0.014   0\n\nRandom effects:\n  Name\t  Model\n    f SPDE2 model\n\nModel hyperparameters:\n                                          mean    sd 0.025quant 0.5quant\nPrecision for the Gaussian observations  0.308 0.080      0.177    0.299\nTheta1 for f                             1.928 0.531      0.908    1.920\nTheta2 for f                            -4.134 0.692     -5.533   -4.122\n                                        0.975quant   mode\nPrecision for the Gaussian observations      0.489  0.283\nTheta1 for f                                 2.999  1.883\nTheta2 for f                                -2.808 -4.070\n\nDeviance Information Criterion (DIC) ...............: 231.65\nDeviance Information Criterion (DIC, saturated) ....: 71.69\nEffective number of parameters .....................: 16.69\n\nWatanabe-Akaike information criterion (WAIC) ...: 232.14\nEffective number of parameters .................: 14.00\n\nMarginal log-Likelihood:  -145.00 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\nThat gives nearly the same estimates as from ```INLA```. \n::: {.cell}\n\n```{.r .cell-code}\nmap_prj <- st_transform(map, crs = projMercator)\npredictions1 <- predict(fit, newdata=dp, formula = ~ Intercept + covtemp + covprec + f)\npredictions2 <- predict(fit, newdata=dp, formula = ~ f)\nggplot() +\ngeom_sf(data=predictions1, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/plot-field-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Check the contribution of just the spatial field\nggplot() +\ngeom_sf(data=predictions2, aes(color=mean)) +\n  scale_colour_gradient(low = \"blue\", high = \"yellow\")\n```\n\n::: {.cell-output-display}\n![](inla_inlabru_tutorial_netherlands_data_files/figure-html/plot-field-2.png){width=672}\n:::\n:::\nThat concludes this section, showing how to fit spatial model in ```INLA``` and ```inlabru```. There are a few things more to do: simulating data and seeing how well INLA recovers the parameters, and fitting a temporal model in both packages. But I'll leave these for later.",
    "supporting": [
      "inla_inlabru_tutorial_netherlands_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}